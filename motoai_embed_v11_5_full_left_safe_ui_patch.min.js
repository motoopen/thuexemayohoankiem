/*!
  motoai_embed_v11_5_full_left_safe_ui_patch.js
  MotoAI v11.5 PRO ‚Äî Full Left + SafeZone + UI Patch
  - Everything from v11.3 Pro (context, synonyms, intent, corpus)
  - UI fixes: keyboard handling on iOS, sticky footer, prevent background scroll,
    visualViewport debouncing, robust safe-zone avoidance, focus/scroll handling
  - Runtime hardening: safe localStorage, always-clear typing, restore state
  - Debug overlay & dev API
  - By: MotoOpen (2025) ‚Äî embed-ready
*/

(function () {
  // ---------- PREVENT DOUBLE LOAD ----------
  if (window.MotoAI_v11_5_LOADED) return;
  window.MotoAI_v11_5_LOADED = true;

  const LOG = (...a) => { try { console.log('[MotoAI v11.5]', ...a); } catch(e) {} };

  LOG('Booting MotoAI v11.5 PRO (Full Left Safe + UI Patch)');

  // ---------- AUTO-INIT ----------
  const MAX_RETRY = 40;
  const RETRY_DELAY = 200;
  let retryCount = 0;
  if (!window.MotoAI_INIT_STARTED) window.MotoAI_INIT_STARTED = false;

  function waitForBodyAndInit() {
    try {
      if (document && document.body && document.body.clientHeight > 0) {
        if (window.MotoAI_INIT_STARTED) { LOG('Init already started.'); return; }
        window.MotoAI_INIT_STARTED = true;
        LOG('‚úÖ Body ready ‚Äî initializing MotoAI v11.5...');
        setTimeout(initMotoAI, 80);
        return;
      }
    } catch (e) { LOG('Body check error', e); }
    retryCount++;
    if (retryCount <= MAX_RETRY) {
      LOG(`‚è≥ Waiting for body... retry ${retryCount}/${MAX_RETRY}`);
      setTimeout(waitForBodyAndInit, RETRY_DELAY + retryCount * 20);
    } else {
      LOG('‚ùå Body not ready ‚Äî aborting MotoAI init.');
    }
  }

  if (document.readyState === 'complete' || document.readyState === 'interactive') {
    setTimeout(waitForBodyAndInit, 60);
  } else {
    window.addEventListener('load', waitForBodyAndInit, { once: true });
  }

  // ---------- MAIN ----------
  function initMotoAI() {
    // Prevent multiple injections
    if (document.getElementById('motoai-root')) { LOG('Already injected - abort.'); return; }

    LOG('Injecting UI & logic...');

    // ---------- CONFIG ----------
    const CFG = {
      version: '11.5-pro',
      placement: 'left',
      safeLeftOffset: 28,
      maxCorpusSentences: 1400,
      minSentenceLen: 14,
      embedNgram: 3,
      minScoreThreshold: 0.06,
      maxSavedMessages: 300,
      contextSize: 4,
      suggestionTags: [
        { q: 'Xe s·ªë', label: 'üèç Xe s·ªë' },
        { q: 'Xe ga', label: 'üõµ Xe ga' },
        { q: 'Xe 50cc', label: 'üö≤ Xe 50cc' },
        { q: 'Th·ªß t·ª•c', label: 'üìÑ Th·ªß t·ª•c' }
      ],
      corpusKey: 'MotoAI_v11_5_corpus_v1',
      sessionKey: 'MotoAI_v11_5_session_v1',
      memoryKey: 'MotoAI_v11_5_memory_v1'
    };

    // ---------- HTML ----------
    const html = `
      <div id="motoai-root" data-placement="${CFG.placement}" aria-hidden="false">
        <div id="motoai-bubble" role="button" aria-label="M·ªü MotoAI" title="M·ªü MotoAI">ü§ñ</div>

        <div id="motoai-overlay" aria-hidden="true">
          <div id="motoai-card" role="dialog" aria-modal="true" aria-hidden="true">
            <div id="motoai-handle" aria-hidden="true"></div>

            <header id="motoai-header">
              <div class="title">MotoAI Assistant</div>
              <div class="tools">
                <button id="motoai-clear" title="X√≥a h·ªôi tho·∫°i">üóë</button>
                <button id="motoai-close" title="ƒê√≥ng">‚úï</button>
              </div>
            </header>

            <main id="motoai-body" tabindex="0" role="log" aria-live="polite">
              <div class="m-msg bot">üëã Ch√†o b·∫°n! M√¨nh l√† MotoAI ‚Äî h·ªèi th·ª≠ "Xe ga", "Xe s·ªë", "Xe 50cc", ho·∫∑c "Th·ªß t·ª•c" nh√©!</div>
            </main>

            <div id="motoai-suggestions" role="toolbar" aria-label="G·ª£i √Ω nhanh"></div>

            <footer id="motoai-footer">
              <div id="motoai-typing" aria-hidden="true"></div>
              <input id="motoai-input" placeholder="Nh·∫≠p c√¢u h·ªèi..." autocomplete="off" aria-label="Nh·∫≠p c√¢u h·ªèi" />
              <button id="motoai-send" aria-label="G·ª≠i">G·ª≠i</button>
            </footer>
          </div>
        </div>
      </div>
    `;
    document.body.insertAdjacentHTML('beforeend', html);

    // ---------- CSS (includes sticky footer + body lock when open) ----------
    const css = `
      :root{ --m15-accent:#007aff; --m15-radius:16px; --m15-card-bg: rgba(255,255,255,0.94); --m15-blur: blur(10px) saturate(140%); --m15-vh:1vh; }
      #motoai-root{ position: fixed; bottom: 18px; z-index: 2147483000; pointer-events: none; left: 16px; }
      #motoai-root[data-placement="left"]{ left: 16px; } #motoai-root[data-placement="right"]{ right: 16px; left: auto; }

      #motoai-bubble{ pointer-events: auto; width:56px; height:56px; border-radius:14px; display:flex;align-items:center;justify-content:center;font-size:26px;background:var(--m15-accent);color:#fff;cursor:pointer;box-shadow:0 10px 28px rgba(2,6,23,0.18); transition: transform .12s ease; user-select:none; }
      #motoai-bubble:active{ transform: scale(0.96); }

      #motoai-overlay{ position: fixed; inset: 0; display:flex; align-items:flex-end; justify-content:center; padding:12px; pointer-events:none; transition: background .24s ease, padding-bottom .2s ease; z-index:2147482999; }
      #motoai-overlay.visible{ background: rgba(0,0,0,0.18); pointer-events: auto; }
      #motoai-card{ width: min(920px, calc(100% - 36px)); max-width:920px; height: calc(var(--m15-vh,1vh) * 72); min-height:320px; border-radius: var(--m15-radius) var(--m15-radius) 12px 12px; background: var(--m15-card-bg); backdrop-filter: var(--m15-blur); -webkit-backdrop-filter: var(--m15-blur); box-shadow:0 -18px 60px rgba(0,0,0,0.22); display:flex; flex-direction:column; overflow:hidden; transform: translateY(110%); opacity:0; pointer-events:auto; transition: transform .36s cubic-bezier(.2,.9,.2,1), opacity .28s ease; }
      #motoai-overlay.visible #motoai-card{ transform: translateY(0); opacity:1; }

      #motoai-handle{ width:64px; height:6px; background: rgba(160,160,160,0.6); border-radius:6px; margin:10px auto; }
      #motoai-header{ display:flex; align-items:center; justify-content:space-between; padding:8px 14px; font-weight:700; color:var(--m15-accent); border-bottom:1px solid rgba(0,0,0,0.06); }
      #motoai-header .tools button{ background:none; border:none; font-size:18px; cursor:pointer; padding:6px 8px; color:#888; }

      #motoai-body{ flex:1; overflow:auto; padding:12px 16px; font-size:15px; -webkit-overflow-scrolling: touch; }
      .m-msg{ margin:8px 0; padding:12px 14px; border-radius:16px; max-width:86%; line-height:1.4; word-break:break-word; box-shadow:0 4px 8px rgba(0,0,0,0.06); }
      .m-msg.bot{ background: rgba(255,255,255,0.96); color:#111; }
      .m-msg.user{ background: linear-gradient(180deg,var(--m15-accent),#00b6ff); color:#fff; margin-left:auto; }

      #motoai-suggestions{ display:flex; gap:8px; justify-content:center; flex-wrap:wrap; padding:8px 12px; border-top:1px solid rgba(0,0,0,0.04); background: rgba(255,255,255,0.6); }
      #motoai-suggestions button{ border:none; background: rgba(0,122,255,0.08); color:var(--m15-accent); padding:8px 12px; border-radius:12px; cursor:pointer; font-weight:600; }

      /* Sticky footer: ensures footer stays visible inside card and floats above keyboard */
      #motoai-footer{ position: sticky; bottom: 0; display:flex; align-items:center; padding:10px 12px; border-top:1px solid rgba(0,0,0,0.06); background: rgba(255,255,255,0.96); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); z-index:2; }
      #motoai-typing{ width:0; height:20px; display:flex; align-items:center; justify-content:center; font-size:14px; color: rgba(0,0,0,0.5); transition: width .2s ease, margin-right .2s ease; overflow:hidden; }
      #motoai-typing span{ width:6px; height:6px; background:rgba(0,0,0,0.3); border-radius:50%; margin:0 2px; animation:m15-dot 1.4s infinite; }
      @keyframes m15-dot{ 0%,80%,100%{ transform: scale(0);} 40%{ transform: scale(1);} }

      #motoai-input{ flex:1; min-width:0; padding:11px 12px; border-radius:14px; border:1px solid rgba(0,0,0,0.08); font-size:15px; background:rgba(255,255,255,0.9); }
      #motoai-send{ background:var(--m15-accent); color:#fff; border:none; border-radius:14px; padding:10px 16px; font-weight:700; cursor:pointer; margin-left:6px; box-shadow:0 2px 6px rgba(0,0,0,0.12); }

      /* prevent background scroll when overlay visible */
      body.motoai-modal-open { overflow: hidden !important; touch-action: none !important; }

      @media (prefers-color-scheme: dark) {
        #motoai-card{ background: rgba(18,18,20,0.94); }
        #motoai-header{ color:#fff; border-bottom:1px solid rgba(255,255,255,0.06); }
        .m-msg.bot{ background: #2b2b2d; color:#eee; }
        #motoai-footer{ background: rgba(8,8,8,0.6); border-top:1px solid rgba(255,255,255,0.06); }
        #motoai-input{ background:#2b2b2d; color:#fff; border:1px solid rgba(255,255,255,0.06); }
      }

      @media (max-width: 600px) {
        #motoai-overlay{ padding:0; align-items:flex-end; }
        #motoai-card{ width:100%; max-width:100%; height: calc(var(--m15-vh,1vh) * 100 - 28px); max-height: calc(var(--m15-vh,1vh) * 100 - 28px); min-height:200px; border-radius: var(--m15-radius) var(--m15-radius) 0 0; transform: translateY(100%); }
        #motoai-overlay.visible #motoai-card{ transform: translateY(0); }
      }
    `;
    const style = document.createElement('style');
    style.textContent = css;
    document.head.appendChild(style);

    // ---------- ELEMENTS ----------
    const $root = document.getElementById('motoai-root');
    const $bubble = document.getElementById('motoai-bubble');
    const $overlay = document.getElementById('motoai-overlay');
    const $card = document.getElementById('motoai-card');
    const $body = document.getElementById('motoai-body');
    const $suggestions = document.getElementById('motoai-suggestions');
    const $typing = document.getElementById('motoai-typing');
    const $input = document.getElementById('motoai-input');
    const $send = document.getElementById('motoai-send');
    const $clear = document.getElementById('motoai-clear');
    const $close = document.getElementById('motoai-close');
    const $footer = document.getElementById('motoai-footer');

    // ---------- STATE ----------
    let corpus = [];
    let chatHistory = [];
    let memory = {};
    let isCardOpen = false;
    let contextHistory = [];
    let debugOpen = false;

    // ---------- SAFE localStorage ----------
    function safeSetItem(k, v) {
      try { localStorage.setItem(k, v); return true; }
      catch (e) {
        console.warn('[MotoAI] localStorage.setItem failed:', e && e.message);
        try { localStorage.removeItem(CFG.sessionKey); localStorage.setItem(k, v); return true; } catch (err) { return false; }
      }
    }
    function safeGetItem(k) { try { return localStorage.getItem(k); } catch (e) { return null; } }
    function safeRemoveItem(k) { try { localStorage.removeItem(k); } catch (e) {} }

    // ---------- TEXT NORMALIZE & EMBEDDING ----------
    function normalizeTextForTokens(text) {
      return String(text || '').toLowerCase().replace(/[^\w√Ä-·ªπ0-9\s]/g, ' ').replace(/\s+/g, ' ').trim();
    }
    function generateEmbeddings(text) {
      const map = new Map();
      const clean = normalizeTextForTokens(text);
      if (!clean) return map;
      const words = clean.split(' ').filter(w => w.length > 2);
      for (let i=0;i<words.length;i++){
        for (let n=1;n<=CFG.embedNgram && i+n<=words.length;n++){
          const token = words.slice(i,i+n).join(' ');
          map.set(token, (map.get(token)||0)+1);
        }
      }
      return map;
    }
    function dotProduct(a,b){ let s=0; for (const [k,v] of a) if (b.has(k)) s+= v * b.get(k); return s; }
    function magnitude(m){ let s=0; for (const v of m.values()) s+= v*v; return Math.sqrt(s); }
    function cosineSimilarity(a,b){ const ma=magnitude(a), mb=magnitude(b); if (ma===0||mb===0) return 0; return dotProduct(a,b)/(ma*mb); }

    // ---------- SYNONYMS & INTENT ----------
    const SYNONYMS = {
      'xe tay ga': ['xe ga','tay ga'],
      'xe s·ªë': ['c√¥n tay','xe c√¥n'],
      'gi√°': ['bao nhi√™u','m·∫•y ti·ªÅn','gi√° c·∫£'],
      'mua': ['mua xe','mua ·ªü ƒë√¢u','ƒë·∫∑t'],
      'b·ªÅn': ['ƒë·ªô b·ªÅn','ch·∫•t l∆∞·ª£ng']
    };
    function applySynonyms(q){
      const norm = normalizeTextForTokens(q);
      const tokens = norm.split(' ').filter(Boolean);
      const set = new Set(tokens);
      for (const [canon,arr] of Object.entries(SYNONYMS)){
        for (const s of arr){
          if (norm.includes(s)) canon.split(' ').forEach(t=>set.add(t));
        }
        if (norm.includes(canon)) arr.forEach(s=>s.split(' ').forEach(t=>set.add(t)));
      }
      return Array.from(set).join(' ');
    }
    function detectIntent(q){
      const t = q.toLowerCase();
      if (/\b(gi√°|bao nhi√™u|m·∫•y ti·ªÅn|gi√° c·∫£|m·ª©c gi√°)\b/.test(t)) return 'price';
      if (/\b(mua|mua ·ªü|mua xe|ƒë·∫∑t)\b/.test(t)) return 'buy';
      if (/\b(th·ªß t·ª•c|gi·∫•y t·ªù|h·ªì s∆°|ƒëƒÉng k√Ω)\b/.test(t)) return 'procedure';
      if (/\b(so s√°nh|so v·ªõi|kh√°c|h∆°n|k√©m)\b/.test(t)) return 'compare';
      if (/\b(b·ªÅn|ƒë·ªô b·ªÅn|ch·∫•t l∆∞·ª£ng|b·∫£o h√†nh)\b/.test(t)) return 'durability';
      if (/\b(ch√†o|hello)\b/.test(t)) return 'greeting';
      if (/\b(c·∫£m ∆°n|thanks)\b/.test(t)) return 'thanks';
      return 'unknown';
    }

    // ---------- CONTEXT ----------
    function rememberContext(q){ if (!q) return; contextHistory.push(q); if (contextHistory.length>CFG.contextSize) contextHistory.shift(); }
    function getContextSummary(){ return contextHistory.join(' | '); }

    // ---------- CORPUS ----------
    function buildCorpus(){
      LOG('Building corpus...');
      try{
        const s = new Set();
        const all = document.body ? document.body.innerText : '';
        if (!all) { LOG('No body text'); return; }
        const lines = all.split(/[\n\r]+/);
        for (const line of lines){
          const segs = line.split(/[.!?]+/) || [];
          for (const snt of segs){
            const clean = snt.trim();
            if (clean.length >= CFG.minSentenceLen) s.add(clean);
          }
        }
        const arr = Array.from(s).slice(0, CFG.maxCorpusSentences);
        corpus = arr.map(t => ({ text: t, vec: generateEmbeddings(t) }));
        try { safeSetItem(CFG.corpusKey, JSON.stringify(corpus)); } catch(e){ LOG('persist corpus fail', e); }
        LOG(`Corpus built (${corpus.length})`);
      }catch(e){ console.error('buildCorpus err', e); }
    }

    // ---------- FIND BEST MATCH ----------
    function findBestMatch(q){
      if (!corpus || corpus.length===0) return null;
      let expanded = applySynonyms(q);
      if (contextHistory.length) expanded += ' ' + contextHistory.join(' ');
      const qvec = generateEmbeddings(expanded);
      if (qvec.size === 0) return null;
      let best = -1, bestText=null;
      for (const it of corpus){
        const ivel = it.vec || generateEmbeddings(it.text);
        if (!it.vec) it.vec = ivel;
        if (ivel.size===0) continue;
        const sc = cosineSimilarity(qvec, ivel);
        if (sc > best) { best = sc; bestText = it.text; }
      }
      return best > CFG.minScoreThreshold ? { text: bestText, score: best } : null;
    }

    // ---------- PERSISTENCE ----------
    function loadData(){
      try{
        const mem = safeGetItem(CFG.memoryKey); if (mem) memory = JSON.parse(mem);
      }catch(e){ LOG('load memory err', e); }
      try{
        const sess = safeGetItem(CFG.sessionKey); if (sess) { chatHistory = JSON.parse(sess) || []; if (chatHistory.length>0){ $body.innerHTML=''; chatHistory.forEach(m=>addMessage(m.sender,m.text,true)); } }
      }catch(e){ LOG('load session err', e); }
      try{
        const stored = safeGetItem(CFG.corpusKey);
        if (stored) {
          corpus = JSON.parse(stored);
          if (Array.isArray(corpus) && corpus.length>0 && !corpus[0].vec) { corpus.forEach(it=>it.vec=generateEmbeddings(it.text)); safeSetItem(CFG.corpusKey, JSON.stringify(corpus)); }
        } else { setTimeout(buildCorpus, 700); }
      }catch(e){ LOG('load corpus err', e); setTimeout(buildCorpus, 700); }
    }
    function saveSession(){ try{ safeSetItem(CFG.sessionKey, JSON.stringify(chatHistory.slice(-CFG.maxSavedMessages))); }catch(e){ LOG('saveSession err', e); } }
    function saveMemory(){ try{ safeSetItem(CFG.memoryKey, JSON.stringify(memory)); }catch(e){ LOG('saveMemory err', e); } }

    // ---------- UI HELPERS ----------
    function applySafePositioning(){
      try{
        const fixed = detectLeftFixedZones();
        const base = { left: 16, bottom: 18 };
        if (!fixed || fixed.length===0) { $root.style.left = base.left + 'px'; $root.style.bottom = base.bottom + 'px'; return; }
        let maxBottomOccupy = 0;
        for (const r of fixed){ if (r.bottom >= (window.innerHeight - 140)) maxBottomOccupy = Math.max(maxBottomOccupy, (window.innerHeight - r.top)); }
        const left = base.left + CFG.safeLeftOffset;
        const bottom = maxBottomOccupy > 0 ? Math.min(220, base.bottom + maxBottomOccupy) : base.bottom;
        $root.style.left = left + 'px';
        $root.style.bottom = bottom + 'px';
      }catch(e){ LOG('applySafePositioning err', e); }
    }

    function detectLeftFixedZones(){
      try{
        const nodes = Array.from(document.querySelectorAll('body *'));
        const rects = [];
        for (const el of nodes){
          const st = window.getComputedStyle(el);
          if (!st || st.visibility==='hidden' || st.display==='none') continue;
          if (st.position==='fixed' || st.position==='sticky'){
            const r = el.getBoundingClientRect();
            if (r.width<8 || r.height<8) continue;
            // near left or large sticky
            if (r.left <= 160 || Math.abs(r.left) < 2 || r.right <= 160) rects.push(r);
          }
        }
        return rects;
      }catch(e){ LOG('detectLeftFixedZones err', e); return []; }
    }

    function setTyping(t){ if (t){ $typing.innerHTML = '<span></span><span></span><span></span>'; $typing.style.width='42px'; $typing.style.marginRight='6px'; } else { $typing.innerHTML=''; $typing.style.width='0px'; $typing.style.marginRight='0px'; } }

    function autoScroll(){
      try{ requestAnimationFrame(()=>{ $body.scrollTop = $body.scrollHeight; }); }catch(e){ try{ $body.scrollTop = $body.scrollHeight; }catch(err){} }
    }

    function addMessage(sender, text, noSave=false){
      try{
        const d = document.createElement('div'); d.className = 'm-msg ' + sender; d.textContent = text;
        $body.appendChild(d);
        requestAnimationFrame(()=>autoScroll());
        if (!noSave) { chatHistory.push({ sender, text, ts: Date.now() }); saveSession(); }
      } catch(e){ console.error('addMessage err', e); }
    }

    // ---------- MEMORY PATTERN ----------
    function handleMemoryText(q){
      const m = q.match(/(?:t√¥i l√†|t√™n t√¥i l√†) ([A-Za-z√Ä-·ªπ ]+)/iu);
      if (m && m[1]) { memory.userName = m[1].trim(); saveMemory(); return `Ch√†o ${memory.userName}! R·∫•t vui ƒë∆∞·ª£c g·∫∑p b·∫°n. B·∫°n c·∫ßn t∆∞ v·∫•n v·ªÅ xe g√¨?`; }
      return null;
    }

    // ---------- BOT LOGIC ----------
    function composeResponse(raw){
      const q = String(raw||'').trim();
      if (!q) return null;
      rememberContext(q);
      const mem = handleMemoryText(q.toLowerCase());
      if (mem) return mem;
      const intent = detectIntent(q);
      const match = findBestMatch(q);
      if (match) {
        if (intent === 'price') return `${match.text} (Tham kh·∫£o: gi√° c√≥ th·ªÉ thay ƒë·ªïi theo ƒë·∫°i l√Ω v√† th·ªùi ƒëi·ªÉm.)`;
        if (intent === 'compare') return `M√¨nh t√¨m ƒë∆∞·ª£c: ${match.text}. B·∫°n mu·ªën m√¨nh so s√°nh th√™m kh√¥ng?`;
        return match.text;
      }
      if (intent === 'greeting') return memory.userName ? `Ch√†o ${memory.userName}! B·∫°n c·∫ßn m√¨nh gi√∫p g√¨?` : 'Ch√†o b·∫°n! M√¨nh l√† MotoAI, m√¨nh c√≥ th·ªÉ gi√∫p g√¨ cho b·∫°n?';
      if (intent === 'thanks') return 'Kh√¥ng c√≥ g√¨! M√¨nh gi√∫p ƒë∆∞·ª£c g√¨ n·ªØa kh√¥ng?';
      if (contextHistory.length) return `√ù b·∫°n c√≥ li√™n quan t·ªõi: "${contextHistory[contextHistory.length-1]}" ch·ª©? B·∫°n mu·ªën h·ªèi r√µ h∆°n ƒëi·ªÅu g√¨?`;
      return 'M√¨nh ch∆∞a hi·ªÉu r√µ l·∫Øm ‚Äî b·∫°n th·ª≠ h·ªèi v·ªÅ "xe ga", "xe s·ªë", ho·∫∑c "th·ªß t·ª•c" nh√©!';
    }

    // ---------- USER INPUT HANDLER ----------
    async function handleUserInput(){
      const q = ($input.value || '').trim();
      if (!q) return;
      addMessage('user', q);
      $input.value = '';
      $input.disabled = true;
      $send.disabled = true;
      setTyping(true);

      try{
        await new Promise(r => setTimeout(r, 380 + Math.random()*420));
        const resp = composeResponse(q);
        addMessage('bot', resp || 'M√¨nh ch∆∞a t√¨m th·∫•y th√¥ng tin ph√π h·ª£p ‚Äî b·∫°n th·ª≠ di·ªÖn ƒë·∫°t kh√°c nh√©.');
      }catch(e){
        LOG('handleUserInput err', e);
        try{ addMessage('bot', 'M√¨nh g·∫∑p l·ªói nh·ªè khi x·ª≠ l√Ω ‚Äî th·ª≠ l·∫°i nh√©.'); }catch(err){}
      }finally{
        setTyping(false);
        $input.disabled = false;
        $send.disabled = false;
        // ensure input visible on mobile keyboard
        try {
          $input.focus({ preventScroll: true });
          setTimeout(()=>{ // scroll footer into view smoothly to ensure not hidden
            try { $footer.scrollIntoView({ behavior: 'smooth', block: 'end' }); } catch(e) {}
          }, 50);
        } catch(e){}
      }
    }

    // ---------- VIEWPORT & KEYBOARD (robust iOS fix) ----------
    // Debounce helper
    function debounce(fn, wait){ let t; return function(...a){ clearTimeout(t); t = setTimeout(()=>fn.apply(this,a), wait); }; }

    // Called when keyboard/viewport changes
    function onViewportChange(){
      try {
        // update CSS variable
        const vh = window.innerHeight * 0.01;
        document.documentElement.style.setProperty('--m15-vh', `${vh}px`);
        if (isCardOpen && window.visualViewport) {
          const v = window.visualViewport;
          const keyboardHeight = Math.max(0, window.innerHeight - v.height);
          const basePadding = (window.innerWidth <= 600) ? 0 : 12;
          $overlay.style.paddingBottom = `${basePadding + keyboardHeight}px`;
          // ensure footer visible
          try { $footer.scrollIntoView({ behavior: 'smooth', block: 'end' }); } catch(e){}
        } else {
          $overlay.style.paddingBottom = '';
        }
        autoScroll();
      } catch(e) { LOG('onViewportChange err', e); }
    }
    const debouncedViewport = debounce(onViewportChange, 70);

    // Listen visualViewport if supported
    if (window.visualViewport) {
      window.visualViewport.addEventListener('resize', debouncedViewport);
      window.visualViewport.addEventListener('scroll', debouncedViewport);
    }
    window.addEventListener('resize', debouncedViewport);

    // When focusing input on iOS, ensure scroll and prevent default page zoom/pan issues
    $input.addEventListener('focus', () => {
      try {
        // Lock body scroll to avoid underlying page moving
        document.body.classList.add('motoai-modal-open');
      } catch(e){ }
      // when focusing, scroll footer into view after tiny delay
      setTimeout(()=>{ try { $footer.scrollIntoView({ behavior: 'smooth', block: 'end' }); } catch(e) {} }, 120);
    });
    $input.addEventListener('blur', () => {
      try { document.body.classList.remove('motoai-modal-open'); } catch(e){}
    });

    // ---------- EVENTS ----------
    function toggleCard(show){
      isCardOpen = (typeof show === 'boolean') ? show : !isCardOpen;
      $overlay.classList.toggle('visible', isCardOpen);
      $overlay.setAttribute('aria-hidden', !isCardOpen);
      $card.setAttribute('aria-hidden', !isCardOpen);
      if (isCardOpen){
        // lock body scroll
        document.body.classList.add('motoai-modal-open');
        applySafePositioning();
        setTyping(false);
        setTimeout(()=>{ try{ $input.focus({ preventScroll: true }); $footer.scrollIntoView({ behavior: 'smooth', block: 'end' }); }catch(e){} }, 220);
      } else {
        document.body.classList.remove('motoai-modal-open');
        $overlay.style.paddingBottom = '';
        $card.style.maxHeight = '';
      }
    }

    function initEvents(){
      $bubble.addEventListener('click', (e) => {
        if (e.altKey) { toggleDebugOverlay(); return; }
        toggleCard(true);
      });
      $close && $close.addEventListener('click', ()=>toggleCard(false));
      $clear && $clear.addEventListener('click', ()=>{ handleClear(); });
      $send && $send.addEventListener('click', handleUserInput);
      $input && $input.addEventListener('keydown', (e)=>{ if (e.key === 'Enter' && !e.shiftKey){ e.preventDefault(); handleUserInput(); } });

      $overlay.addEventListener('click', (e)=>{ if (e.target === $overlay) toggleCard(false); });

      $suggestions.addEventListener('click', (e)=>{
        if (e.target && e.target.tagName === 'BUTTON'){ $input.value = e.target.dataset.query || ''; setTimeout(handleUserInput, 60); }
      });

      // re-check safe zones periodically (for SPA)
      const t = setInterval(()=>applySafePositioning(), 2000);
      setTimeout(()=>clearInterval(t), 60000);
    }

    // ---------- DEBUG OVERLAY ----------
    let debugEl = null;
    function createDebugOverlay(){
      if (debugEl) return;
      debugEl = document.createElement('div');
      debugEl.id = 'motoai-debug-overlay';
      Object.assign(debugEl.style, { position:'fixed', right:'12px', top:'12px', zIndex:2147484000, background:'rgba(0,0,0,0.7)', color:'#fff', padding:'10px', borderRadius:'8px', maxWidth:'380px', fontSize:'13px', display:'none', pointerEvents:'auto' });
      debugEl.innerHTML = `<div style="font-weight:700;margin-bottom:6px">MotoAI Debug v11.5</div><pre id="motoai-debug-pre" style="white-space:pre-wrap"></pre>`;
      document.body.appendChild(debugEl);
    }
    function toggleDebugOverlay(){ if (!debugEl) createDebugOverlay(); debugOpen = !debugOpen; debugEl.style.display = debugOpen ? 'block' : 'none'; if (debugOpen) updateDebug(); }
    function updateDebug(){ if (!debugEl) return; const p = debugEl.querySelector('#motoai-debug-pre'); const info = { version: CFG.version, placement: CFG.placement, corpusSize: corpus.length, sessionLen: chatHistory.length, memoryKeys: Object.keys(memory), contextHistory, userAgent: navigator.userAgent }; p.textContent = JSON.stringify(info, null, 2); }

    // ---------- CLEAR ----------
    function handleClear(){
      chatHistory = [];
      try { safeRemoveItem(CFG.sessionKey); } catch(e){}
      $body.innerHTML = '';
      const g = memory.userName ? `Ch√†o ${memory.userName}! B·∫°n c·∫ßn h·ªó tr·ª£ g√¨ ti·∫øp theo?` : 'Ch√†o b·∫°n! M√¨nh l√† MotoAI, m√¨nh c√≥ th·ªÉ gi√∫p g√¨ cho b·∫°n?';
      addMessage('bot', g, true);
    }

    // ---------- STARTUP ----------
    function renderSuggestions(){
      $suggestions.innerHTML = '';
      (CFG.suggestionTags || []).forEach(t => { const b = document.createElement('button'); b.textContent = t.label; b.dataset.query = t.q; $suggestions.appendChild(b); });
    }

    function startUp(){
      renderSuggestions();
      loadData();
      initEvents();
      applySafePositioning();
      // initial greeting
      if (!chatHistory || chatHistory.length === 0){
        $body.innerHTML = '';
        const g = memory.userName ? `Ch√†o ${memory.userName}! B·∫°n s·∫µn s√†ng t√¨m hi·ªÉu v·ªÅ xe ch∆∞a?` : 'üëã Ch√†o b·∫°n! M√¨nh l√† MotoAI ‚Äî h·ªèi th·ª≠ "Xe ga", "Xe s·ªë", "Xe 50cc", ho·∫∑c "Th·ªß t·ª•c" nh√©!';
        addMessage('bot', g, true);
      }
      LOG('Ready ‚úÖ MotoAI v11.5 PRO (UI Patch)');
    }

    // ---------- DEV API ----------
    window.MotoAI_v11_5 = {
      cfg: CFG,
      open: ()=>toggleCard(true),
      close: ()=>toggleCard(false),
      rebuildCorpus: buildCorpus,
      debug: toggleDebugOverlay,
      getCorpusSize: ()=>corpus.length,
      getSession: ()=>chatHistory.slice(),
      setMemory: (m)=>{ memory = Object.assign(memory||{}, m); saveMemory(); }
    };

    // ---------- FINALLY ----------
    startUp();

  } // end initMotoAI

} )();
